enum Token {
    @keyword
    enum Keyword {
        As : { precedence }
        And : { precedence = }
        Abstract
        Class
        Interface
        Mixin
        Type
        Infer
        Of
        With
        Static
        New
        Break
        Or : { precedence = }
        Not : { precedence = TODO }
        Is
        If
        Unless
        Match
        While
        Until
        For
        Loop
        Fn
        Let
        Const
    }

    enum Balanced {
        LeftParen = '('
        RightParen = ')'
        LeftBracket = '{'
        RightBracket '}'
        LeftBrace = '['
        RightBracket = ']'
    }

    @onScan(scanString)
    DoubleQuotes = '"'
    SingleQuote = '\''
    Colon = ':'
    ColonColon
    At = '@'
    Hash = '#'
    Dollar = '$'
    enum SuffixOperators = {
        Bang = '!' : {
            precedence = 67
        }
        Question = '?' : {
            precedence = 67
        }
    }

    enum InfixOperators {
        Plus = '+'
        PlusPlus
        Minus = '-'
        Star = '*'
        StarStar
        Slash = '/'
        Percent = '%'
        Carat = '^'
        Ampersand = '&'
        Pipe = '|'
        LessLess
        LessLessGreater
        @deferScanning
        GreaterGreater
        @deferScanning
        GreaterGreaterGreater
        @deferScanning
        GreaterGreaterLess
    }

    enum Assignment {
        Equals = '='
        @for operator in Super.InfixOperators {
            @(operator.name ++ "Equals")
        }
        AndEquals
        OrEquals
    }

    enum Comparison {
        EqualsEquals
        BangEquals
        Less = '<'
        Greater = '>'
        LessEquals
        GreaterEquals
    }

    // Section
    Identifier
    AtIdentifier
    HashIdentifier
    ColonIdentifier

    enum Integer {
        @number("09", default)
        Digit
        @number("09afAF", format = "x")
        Hexadecimal
        @number("07", format = "o")
        Octal
        @number("01", format = "b")
        Binary
    }

    enum Float {
        @number("09", default)
        Digit
        @number("09afAF", format = "x")
        Hexadecimal
        @number("07", format = "o")
        Octal
        @number("01", format = "b")
        Binary
    }

    @after(Number | Float)
    enum NumberType {
        U8
        U16
        U32
        U64
        U128
        Usize
        I8
        I16
        I32
        I64
        I128
        Isize
        F8
        F16
        F32
        F64
        F128
        Fsize
        D8
        D16
        D32
        D64
        D128
        Dsize
    }
} : {
    precedence: u16? = nil
    associativity: :left | :right = :left
}

abstract class Parsable {
    @keywords
    abstract class Statement {
        @annotateFields {
            parent: @afterToken(Of)
            with: @afterToken(With)
            itemType: @afterToken(Colon)
            body: @delimited("{}")
            value: @afterToken(Equals)
        }

        abstract class NewType {
            type Statement
            name: Identifier
            generics: Generic[]

            class Class {
                type Statement = Field
                | StaticField
                | TypeDefinition
                | Method
                | StaticMethod
                | (Class | AbstractClass)
                
                parent: Type?
                with: Type[]?
                body: Statement[]
            }

            class Interface {
                type statement = PartialStaticField
                | PartialTypeDefinition
                | Method
                | StaticMethod
                | PartialStaticMethod
                | PartialMethod
                | (Class | AbstractClass | Interface)

                @afterToken(Of)
                parent: Type?
                body: Statement[]
            }

            class AbstractClass {
                type Statement = Class.Statement | Interface.Statement ~ Interface

                @afterToken(Of)
                parent: Type?
                @afterToken(With)
                with: Type[]?
                body: Statement[]
            }

            class Mixin {
                body: Class.Statement[]
            }

            class Enum {
                type Value = nil
                | @afterToken(Equals) Expression
                | Tuple
                | Object
                type Statement = {
                    name: Identifier,
                    value: Value,
                    @after(Colon)
                    @delimited("{}")
                    data: Class.Statement[]?
                }
                | Method
                | StaticMethod
                | Box<Enum>

                body: Statement[]
                @after(Colon)
                @delimited("{}")
                data: Interface.Statement[]?
            }

            @token(Type)
            class TypeDefinition {
                value: Type
            }
        }

        @token(Const)
        class Constant {
            name: Identifier
            item_type: Type
            value: Expression
        }

        @token(Fn)
        class Function {
            name: Identifier
            generics: Generic[]
            parameters: Parameters
            @afterToken(Colon)
            return_type: Type?
            body: FunctionStatement[]
        }

        class Use {
            name: Identifier | SelfKeyword | SuperKeyword,
            @after(Dot)
            subPath: Box<Use>?
        }

        class Eof {}
    }

    abstract class Expression {
        abstract class Operator {
            operator: Token.Operator

            class Unary {
                expr: Expression
            }

            class Binary {
                left: Expression
                right: Expression
            }
        }

        class If {
            ifBranch: ConditionalBlock
            @afterToken(Else)
            elseIfBranches: ConditionalBlock[]
            @afterToken(Else)
            elseBranch: Block?
        }

        class Match {
            expr: Expression
            @delimited("{}")
            @commaSeparated
            branches: MatchClause[]
        }

        class While {}

        class For {}

        class Forever {}

        class Call {}

        class Field {}

        class Subscript {}

        class Dereference {}

        class Return {
            expr: Expression?
        }

        class Break {
            @afterToken(Colon)
            label: Identifier?
            expr: Expression?
        }

        class Continue {
            @afterToken(Colon)
            label: Identifier?
        }

        class Identifier {
            token: Token
            
            fn name(): string { token.lexeme }
        }

        class Keyword {
            token: LowercaseSelf | LowercaseSuper
        }
    }

    class MatchClause {
        name: Identifier?
        destructure: Destructure?
        item_type: Type?
        guard_clause: Expression?
    }

    enum Destructure {
        Tuple(matchClause[])
        Array(ArrayDestructure[])
        Object(ObjectDestructure[])
    }

    enum ArrayDestructure {
        @afterToken(DotDotDot)
        Splat(MatchClause?)
        Plain(MatchClause)
    }

    class ObjectDestructure of MatchClause {
        @afterToken(Equals)
        field: Identifier?

        fn field_name() -> string? {
            field or name
        }
    }

    abstract class Literal {
        @keyword
        class Nil {}

        @keyword
        class True {}

        @keyword
        class False {}

        class Symbol of Identifier {}

        class Integer with Parse {
            parsed: usize
            numberType: Type

            static fn parse(parser: &Parser): Self | Error {
                let lexeme = parser.previous().lexeme

                let parsed = if lexeme[0] == '0' {
                    parse_base()?
                } else {
                    usize.fromString(lexeme).mapError(e -> Error.InvalidNumber(e.input))?
                }

                if let numberType = parser.ifNext($ is Token.NumberType) {
                    return Self {
                        parsed,
                        numberType: numberType as? Type.Primitive
                    }
                } else {
                    return Self {
                        parsed,
                        numberType: Type.Primitive.I32
                    }
                }
            }
        }

        class String with Parse {
            type EscapeChar = '\\' | '@'
            static beginning: TokenType = BeginStringQuote

            pieces: Vec<StringPiece>

            static fn escape(esc: string) -> char {
                match esc[1] {
                    'a' => '\x07'
                    'b' => '\x08'
                    'e' => '\x1b'
                    'f' => '\x0c'
                    'r' => '\r'
                    'n' => '\n'
                    't' => '\t'
                    'v' => '\v'
                    'u' => unicode(esc[2..])
                    'x' => hex_escape(esc[2..])
                    '0' => '\0'
                    other => other
                }
            }

            static fn parse(parser: &Parser): Self {
                @map loop {
                    match parser.next().token_type {
                        StringContents => parser.previous().lexeme
                        Backslash => escape(parser.previous().lexeme),
                        At => interpolation(parser)
                        EndStringQuote => break
                    }
                }
            }
        }

        @delimited("()")
        class Tuple {
            items: Expression[]
        }

        @delimited("[]")
        class Array {
            static class Comprehension {
                expr: Expression?
                for_loop: Expression.For
            }

            items: (Expression | Comprehension | Splat)[]
        }

        @delimited("{}")
        class Object {
            static class Field {
                name: Identifier
                value: Expression?
            }

            type Statement = Field
            | Splat

            @commaSeparated
            fields: Statement[]
        }

        class InclusiveRange {
            start: Expression?
            @afterToken(DotDotEquals)
            end: Expression?
        }

        class ExclusiveRange {
            start: Expression?
            @afterToken(DotDot)
            end: Expression?
        }
    }

    type FunctionStatement = Expression
    | Statement.Use
    | Statement.Constant
    | Let

    class Let {
        matchClause: MatchClause
        value: Expression
    }

    enum Type {
        use Statement.NewType.*

        Named {
            root: Identifier | SelfKeyword | SuperKeyword
            @each(@afterToken(Dot))
            path: Identifier[]
            generics: Generic[]
        }
        @afterToken(Interface)
        @delimited("{}")
        Interface(Interface.Statement[])
        @delimited("()")
        Tuple(Type[])
        @delimited("{}")
        Object(ObjectStatement[])
        @syntax("@0 LeftBracket @1 RightBracket")
        Array(Type, Expression)
        @syntax("@0 LeftBracket RightBracket")
        Slice(Type)

        @afterToken(Ampersand)
        Reference(Type)
        @afterToken(Star)
        Pointer(Type)

        @syntax("Fn LeftParen @parameters RightParen (Colon @returnType)?")
        Function {
            parameters: Type.Tuple
            returnType: Type?
        }

        @separated(Ampersand)
        @innerIfSingle
        Intersection(Type[])

        @separated(Pipe)
        @innerIfSingle
        Union(Type[])

        @beforeToken(Question)
        Optional(Type)

        Literal(Literal)
    }

    extend Type.Optional with Desugar {
        fn desugar() => Type.Union([self, Type.Literal(Literal.Nil)])
    }

    class Generic {
        name: Identifier
        @afterToken(Colon)
        supertype: Type?
        @afterToken(Equals)
        default_type: Type?
    }
}